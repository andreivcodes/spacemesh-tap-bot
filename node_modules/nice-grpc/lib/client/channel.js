"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForChannelReady = exports.createChannel = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
function createChannel(address, credentials, options = {}) {
    const match = /^(?:([^:]+):\/\/)?(.*?)(?::(\d+))?$/.exec(address);
    if (match == null) {
        throw new Error(`Invalid address: '${address}'`);
    }
    const [, protocol = 'http', host, port = protocol === 'http' ? '80' : '443'] = match;
    if (protocol === 'http') {
        credentials !== null && credentials !== void 0 ? credentials : (credentials = grpc_js_1.ChannelCredentials.createInsecure());
    }
    else if (protocol === 'https') {
        credentials !== null && credentials !== void 0 ? credentials : (credentials = grpc_js_1.ChannelCredentials.createSsl());
    }
    else {
        credentials !== null && credentials !== void 0 ? credentials : (credentials = grpc_js_1.ChannelCredentials.createInsecure());
        return new grpc_js_1.Channel(address, credentials, options);
    }
    return new grpc_js_1.Channel(`${host}:${port}`, credentials, options);
}
exports.createChannel = createChannel;
async function waitForChannelReady(channel, deadline) {
    while (true) {
        const state = channel.getConnectivityState(true);
        if (state === grpc_js_1.connectivityState.READY) {
            return;
        }
        await new Promise((resolve, reject) => {
            channel.watchConnectivityState(state, deadline, err => {
                if (err != null) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
}
exports.waitForChannelReady = waitForChannelReady;
//# sourceMappingURL=channel.js.map