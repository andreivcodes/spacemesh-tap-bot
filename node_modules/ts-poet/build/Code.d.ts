import { Node } from "./Node";
export declare type DPrintOptions = Record<string, unknown>;
/** Options for `toStringWithImports`, i.e. for the top-level, per-file output. */
export interface ToStringOpts {
    /** The intended file name of this code; used to know whether we can skip import statements that would be from our own file. */
    path?: string;
    /** Modules to use a CommonJS-in-ESM destructure fix for. */
    forceDefaultImport?: string[];
    /** Modules to use a CommonJS-in-ESM destructure fix for. */
    forceModuleImport?: string[];
    /** A top-of-file prefix, i.e. eslint disable. */
    prefix?: string;
    /** dprint config settings. */
    dprintOptions?: DPrintOptions;
    /** optional importMappings */
    importMappings?: {
        [key: string]: string;
    };
}
export declare class Code extends Node {
    private literals;
    private placeholders;
    trim: boolean;
    private oneline;
    constructor(literals: TemplateStringsArray, placeholders: any[]);
    /** Returns the code with any necessary import statements prefixed. */
    toStringWithImports(opts?: ToStringOpts): Promise<string>;
    /**
     * Returns the formatted code, without any imports.
     *
     * Note that we don't use `.prettierrc` b/c that requires async I/O to resolve.
     */
    toString(): string;
    asOneline(): Code;
    get childNodes(): unknown[];
    toCodeString(): string;
    private deepFindImports;
    private deepFindDefs;
    private deepConditionalOutput;
    private deepReplaceNamedImports;
    private generateCode;
}
export declare function deepGenerate(object: unknown): string;
/**
 * Represents a symbol defined in the current file.
 *
 * We use this to know if a symbol imported from a different file is going to
 * have a namespace collision.
 */
export declare class Def extends Node {
    symbol: string;
    constructor(symbol: string);
    toCodeString(): string;
    /** Any potentially string/SymbolSpec/Code nested nodes within us. */
    get childNodes(): Node[];
}
